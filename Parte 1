baud rate generator:

module Baud_rate_generator(
    input logic clk, reset,
    input logic [10:0] dvsr,    //divisor
    output logic tick
    );
    //declaration
    logic [10:0] r_reg;
    logic [10:0] r_next;
    
    //body
    //register
    always_ff @(posedge clk, posedge reset)
        if (reset)
            r_reg <= 0;
        else
            r_reg <= r_next;
            
     //next steate logic
     assign r_next = (r_reg == dvsr) ? 0 : r_reg + 1;
     //ouput logic 
     assign tick = (r_reg==1); 
endmodule


uart_rx:

module uart_rx #(parameter DBIT = 8, SB_TICK = 16)(  //#data bits  //#ticks for stop bits
    input logic clk, reset,
    input logic rx, s_tick,
    output logic rx_done_tick,
    output logic [7:0] dout
    );
    
    //fsm state type
    typedef enum {idle, start, data, stop} state_type;
    
    //signal declaration
    state_type state_reg, state_next;
    logic [3:0] s_reg, s_next;
    logic [2:0] n_reg, n_next;
    logic [7:0] b_reg, b_next;
    
    //body
    //FSMD state & data registers
    always_ff @(posedge clk, posedge reset)
        if(reset) begin
            state_reg <= idle;
            s_reg <= 0;
            n_reg <= 0;
            b_reg <= 0;
         end 
         else begin
            state_reg <= state_next;
            s_reg <= s_next;
            n_reg <= n_next;
            b_reg <= b_next;
         end
         
     //FSMD next state logic
     always_comb 
     begin
        state_next = state_reg;
        rx_done_tick = 1'b0;
        s_next <= s_reg;
        n_next <= n_reg;
        b_next <= b_reg;
        case(state_reg)
            idle:
                if (~rx) begin
                    state_next = start;
                    s_next = 0;
                end
            start:
                if (s_tick)
                    if(s_reg == 7) begin
                        state_next = data;
                        s_next = 0;
                        n_next = 0;
                    end
                    else
                        s_next = s_reg + 1;
            data:
                if (s_tick)
                    if (s_reg == 15) begin
                        s_next = 0;
                        b_next = {rx, b_reg[7:1]};
                        if (n_reg == (DBIT-1))
                            state_next = stop;
                        else
                            n_next = n_reg + 1;
                     end
                     else
                        s_next = s_reg + 1;
             stop:
                if(s_tick)
                    if(s_reg == (SB_TICK-1)) begin
                        state_next = idle;
                        rx_done_tick = 1'b1;
                    end
                    else
                        s_next = s_reg +1;
        endcase
      end
       
       //ouput
       assign dout = b_reg;
endmodule


uart_tx:

module uart_tx #(parameter DBIT = 8, SB_TICK = 16)(     //# data bits   ##16 ticks for 1 stop bit
    input logic clk, reset,
    input logic tx_start, s_tick,
    input logic [7:0] din,
    output logic tx_done_tick,
    output logic tx
    );
    
    //fsm state type
    typedef enum {idle, start, data, stop} state_type;
    
    //signal declaration
    state_type state_reg, state_next;
    logic [3:0] s_reg, s_next;
    logic [2:0] n_reg, n_next;
    logic [7:0] b_reg, b_next;
    logic tx_reg, tx_next;
    
    //body
    //FSMD state & data registers
    always_ff @(posedge clk, posedge reset)
        if(reset) begin
            state_reg <= idle;
            s_reg <= 0;
            n_reg <= 0;
            b_reg <= 0;
            tx_reg <= 1'b1;
         end
         else begin
            state_reg <= state_next;
            s_reg <= s_next;
            n_reg <= n_next;
            b_reg <= b_next;
            tx_reg <= tx_next;
         end
         
     //FSMD next state logic & functional units
     always_comb 
     begin
        state_next = state_reg;
        tx_done_tick = 1'b0;
        s_next = s_reg;
        n_next = n_reg;
        b_next = b_reg;
        tx_next = tx_reg;
        
        case(state_reg)
            idle: begin
                tx_next = 1'b1;
                if(tx_start) begin
                    state_next = start;
                    s_next = 0;
                    b_next = din;
                end 
            end
            start: begin
                tx_next = 1'b0;
                if(s_tick)
                    if(s_reg==15) begin
                        state_next = data;
                        s_next = 0;
                        n_next = 0;
                    end
                    else
                        s_next = s_reg + 1;
            end
            data: begin
                tx_next = b_reg[0];
                if(s_tick)
                    if(s_reg == 15) begin
                        s_next = 0;
                        b_next = b_reg >> 1;
                        if (n_reg == (DBIT-1))
                            state_next = stop;
                        else
                            n_next = n_reg + 1;
                     end
                     else
                        s_next = s_reg + 1;
             end
             stop: begin
                tx_next = 1'b1;
                if (s_tick)
                    if (s_reg == (SB_TICK - 1)) begin
                        state_next = idle;
                        tx_done_tick = 1'b1;
                    end
                    else
                        s_next =s_reg + 1;
              end
        endcase
    end
    
    //output
    assign tx = tx_reg;             
endmodule

uart:

module uart #(parameter DBIT = 8, SB_TICK = 16, FIFO_W =2)(     //#data bits, #16 ticks for 1 stop bit, #addr bits of FIFO
    input logic clk, reset,
    input logic rd_uart, wr_uart, rx,
    input logic [7:0] w_data,
    input logic [10:0] dvsr,
    output logic tx_full, rx_empty, tx,
    output logic [7:0] r_data
    );
    
    //signal declaration
    logic tick, rx_done_s_tick, tx_done_tick;
    logic tx_empty, tx_fifo_not_empty;
    logic [7:0] tx_fifo_out, rx_data_out;
    
    //body
    baud_rate_generator baud_rate_generator (.*);
    
    uart_rx #(.DBIT(DBIT), .SB_TICK(SB_TICK)) uart_rx_unit
        (.*, .s_tick(tick), .dout(rx_data_out));
        
    uart_tx #(.DBIT(DBIT), .SB_TICK(SB_TICK)) uart_tx_unit
        (.*, .s_tick(tick), .tx_start(tx_fifo_not_empty), .din(tx_fifo_out));
        
    fifo #(.DATA_WIDTH(DBIT), .ADDR_WIDTH(FIFO_W)) fifo_rx_unit
        (.*, .rd(rd_uart), .wr(rx_done_tick), .w_data(rx_data_out),
            .empty(rx_empty), .full(), .r_data(r_data));
    
    fifo #(.DATA_WIDTH(DBIT), .ADDR_WIDTH(FIFO_W)) fifo_tx_unit
        (.*, .rd(tx_done_tick), .wr(wr_uart), .w_data(w_data),
            .empty(tx_empty), .full(tx_full), .r_data(tx_fifo_out));
            
    assign tx_fifo_not_empty = ~tx_empty;      
     
endmodule

